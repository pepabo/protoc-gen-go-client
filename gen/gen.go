package gen

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/pepabo/protoc-gen-go-client/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	optPackage     = "package"
	optSamePackage = "same_package"
	optWithClose   = "with_close"
)

type Generator struct {
	genp        *protogen.Plugin
	samePackage bool
	withClose   bool
	packageName string
}

func New(genp *protogen.Plugin) *Generator {
	genp.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
	return &Generator{
		genp: genp,
	}
}

func (gen *Generator) Generate() error {
	if err := gen.parseOpts(); err != nil {
		return err
	}
	var tmppf *protogen.File
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		tmppf = pf
	}
	filename := filepath.Join(filepath.Dir(tmppf.GeneratedFilenamePrefix), "client.go")
	g := gen.genp.NewGeneratedFile(filename, tmppf.GoImportPath)

	g.P("// Code generated by protoc-gen-go-client. DO NOT EDIT.")
	g.P("// versions:")
	g.P(fmt.Sprintf("// - protoc-gen-go-client v%s", version.Version))
	g.P("")

	if gen.packageName != "" {
		g.P("package ", gen.packageName)
	} else {
		g.P("package ", tmppf.GoPackageName)
	}
	g.P("")
	g.P(`import (`)
	if gen.withClose {
		g.P(`"context"`)
		g.P("")
	}
	if !gen.samePackage {
		g.P(fmt.Sprintf("%s %s", tmppf.GoPackageName, tmppf.GoImportPath.String()))
	}
	g.P(`"google.golang.org/grpc"`)
	g.P(`)`)

	if gen.withClose {
		// type ClientConn interface
		g.P(`type ClientConnInterface interface {`)
		g.P(`Invoke(ctx context.Context, method string, args interface{}, reply interface{}, opts ...grpc.CallOption) error`)
		g.P(`NewStream(ctx context.Context, desc *grpc.StreamDesc, method string, opts ...grpc.CallOption) (grpc.ClientStream, error)`)
		g.P("Close() error")
		g.P(`}`)
		g.P("")
	}

	// type Client interface
	g.P(`type Client interface {`)
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("%s() %sClient", s.Desc.FullName().Name(), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("%s() %s.%sClient", s.Desc.FullName().Name(), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
		}
	}
	if gen.withClose {
		g.P("Close() error")
	}
	g.P(`}`)
	g.P("")

	// type client struct
	g.P(`type client struct {`)
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("%s %sClient", toLowerCamel(string(s.Desc.FullName().Name())), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("%s %s.%sClient", toLowerCamel(string(s.Desc.FullName().Name())), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
		}
	}
	if gen.withClose {
		g.P("cc ClientConnInterface")
	}
	g.P(`}`)
	g.P("")

	// func New(cc *.ClientConnInterface) *Client
	if gen.withClose {
		g.P(`func New(cc ClientConnInterface) Client {`)
	} else {
		g.P(`func New(cc grpc.ClientConnInterface) Client {`)
	}
	g.P(`return &client{`)
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("%s: New%sClient(cc),", toLowerCamel(string(s.Desc.FullName().Name())), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("%s: %s.New%sClient(cc),", toLowerCamel(string(s.Desc.FullName().Name())), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
		}
	}
	if gen.withClose {
		g.P("cc: cc,")
	}
	g.P(`}`)
	g.P(`}`)
	g.P("")

	// func (c *Client) *
	for _, pf := range gen.genp.Files {
		if !pf.Generate {
			continue
		}
		for _, s := range pf.Services {
			if gen.samePackage {
				g.P(fmt.Sprintf("func (c *client) %s() %sClient {", s.Desc.FullName().Name(), s.Desc.FullName().Name()))
			} else {
				g.P(fmt.Sprintf("func (c *client) %s() %s.%sClient {", s.Desc.FullName().Name(), tmppf.GoPackageName, s.Desc.FullName().Name()))
			}
			g.P(fmt.Sprintf("return c.%s", toLowerCamel(string(s.Desc.FullName().Name()))))
			g.P("}")
			g.P("")
		}
	}
	if gen.withClose {
		g.P("func (c *client) Close() error {")
		g.P("return c.cc.Close()")
		g.P("}")
		g.P("")
	}
	return nil
}

func (gen *Generator) parseOpts() error {
	opts := strings.Split(gen.genp.Request.GetParameter(), ",")
	for _, o := range opts {
		o := strings.TrimSpace(o)
		switch {
		case o == optSamePackage:
			gen.samePackage = true
		case o == optWithClose:
			gen.withClose = true
		case strings.HasPrefix(o, fmt.Sprintf("%s=", optPackage)):
			gen.packageName = strings.TrimPrefix(o, fmt.Sprintf("%s=", optPackage))
		}
	}
	if gen.samePackage && gen.packageName != "" {
		return errors.New("package name cannot be specified if it is the same package as the Go package")
	}
	return nil
}

func toLowerCamel(s string) string {
	runes := []rune(s)
	if len(runes) > 0 {
		runes[0] = unicode.ToLower(runes[0])
	}
	return string(runes)
}
